USE [nft]
GO
/****** Object:  UserDefinedFunction [dbo].[calc_volume_by_gost]    Script Date: 18.11.2019 8:53:04 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:		<Зиновьев О.Н.>
-- Create date: <05.06.2018>
-- Description:	<Вспомогательная функция вычисления объема для процедуры sp_vp_GetTestLabStat2>
--    парсит стоку описания дефектов и вычисляет объем забракованного материала согласно справочнику Weldings_overvolume_sprav
--    содержащему объем материала в одном миллиметре для указанного диаметра и толщины трубы
--    примеры строк описания дефектов:
--      *13П2,0
--      *14,15,16,17,19;ск.П,Н ?-590.
--      *14,15: С100П2,0
--      *14:2П1,5
--      *14:2П1,5?3,0;Ц70П2,0; *15:П2,0; *16:Ц50П2,0;П1,5; *17:Ц50П2,0; *18:Ц20П2,0
--      *14:П1,0х3,0
--      *14:П1,5;*17:П2,0
--      *14:Н25,0; *15:Н50,0;Н30,0; *16:Н50,0;Н110,0; *17:Н30,0;Н120,0
--        
-- =============================================
ALTER FUNCTION [dbo].[calc_volume_by_gost] 
(
    @Diameter float,   -- диаметр трубы
	@Thikness float,   -- толщина стенки трубы
	@Gost varchar(100) -- строка с зашифровкой описания дефектов по госту
)
RETURNS float
AS
BEGIN
 
    -- константы для наглядного отслеживания текущей разбираемой части описания дефекта
    DECLARE @PART_COUNT  int = 0             -- разбирается первая числовая часть - количестов дефектов (целое число или отсутсвует)
	DECLARE @PART_TYPE   int = 1             -- разбирается вторая текстовая часть - описание типа дефекта (буквы и точки)
	DECLARE @PART_LENGTH int = 2             -- разбирается третья числовая часть - длина дефекта (может быть дробная)
    DECLARE @PART_OVER   int = 3             -- разобраны все интересующие данные, началась дополнительная часть. например, описание ширины маскимального дефекта в группе
	DECLARE @PART_CALC   int = 4             -- значения собранные после @PART_OVER посчитаны и ожидается новое описание дефекта 

	DECLARE @Volume     float        = 0     -- переменная для подсчета полного объема
	DECLARE @OverVolume float        = 0     -- объем выборки болгаркой из справочника для данного диаметра и толщины трубы
    DECLARE @Symbol     varchar(1)   = ''    -- текущий разбираемый символ в строке @Gost
	DECLARE @StrPos     int          = 1     -- текущая позиция сканирования строки @Gost
	DECLARE @StrLength  int          = 0     -- длина строки @Gost для того, чтобы не получать это значение в каждом цикле сканирования (микро оптимизация)
	DECLARE @Part       int          = @PART_COUNT
	                                         -- текущая разбираемая часть описания дефекта. содержит одно из значений констант @PART_XXX

    DECLARE @Count      varchar(10) = ''    -- полученные на данный момент числовые символы из начала группы описания дефекта (количество дефектов) 
	DECLARE @Type       varchar(10) = ''    -- тип дефекта. например Н - репровар, П - пора
    DECLARE @Length     varchar(10) = ''    -- полученные на данный момент числовые символы длины дефекта 

	DECLARE @Trace varchar(8000)     = ''

	-- получаем длину избыточного выреза метериала из трубы при устранении одного дефекта
	SET @OverVolume = ISNULL( ( SELECT volume FROM Weldings_overvolume_sprav WHERE diameter = @Diameter AND thikness = @Thikness ), 0 )

	SET @StrLength = len(@Gost)


    WHILE @StrPos <= @StrLength 
	BEGIN
	    
		-- берем следующий символ
		SET @Symbol = SUBSTRING( @Gost, @StrPos, 1 );                             
     

		-- ============================================
		-- обработка разбора части КОЛИЧЕСТВА ДЕФЕКТОВ
		-- ============================================

		IF @Part = @PART_COUNT
		BEGIN

			-- пока встречаются цифры, пишем их в переменную количества дефектов
			-- "*" - особый признак, который может ставиться перед цифрой количества
			IF  @Symbol in ('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ' ')    
            SET @Count = @Count + @Symbol

			-- в режиме количества дефектов встретили букву - началась часть типа дефекта
			IF  @Symbol not in ('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ' ', ':', '*') 
			SET @Part = @PART_TYPE

		END



		-- ============================================
		-- обработка разбора части ТИПА ДЕФЕКТА
		-- ============================================

		IF @Part = @PART_TYPE
		BEGIN
			-- в режиме типа дефекта, пока встречаются не цифры - пишем их в переменную типа
			IF  @Symbol not in ('0', '1', '2', '3', '4', '5', '6', '7', '8', '9')
			SET @Type = @Type + @Symbol

			-- если в режиме типа встретилась цифра - началась часть длины дефекта
			IF  @Symbol in ('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ' ') 
			SET @Part = @PART_LENGTH

		END



		-- ============================================
		-- обработка разбора части ДЛИННЫ ДЕФЕКТА
		-- ============================================

		IF @Part = @PART_LENGTH 
		BEGIN
			-- пока в режиме длины дефекта 
			IF  @Symbol in ('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ' ', '.', ',')
			SET @Length = @Length + @Symbol

			IF  @Symbol not in ('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ' ', '.', ',') 
			SET @Part = @PART_OVER

		END

	                                                                          
		-- ============================================
		-- обработка окончания разбора 
		-- ============================================

		IF @Part = @PART_OVER
		BEGIN

		    -- отсутствующее количество дефектов приводим к 1
			IF @Count = '' SET @Count = '1'                                       
			
			-- для двух случаев не требуется увеличивать объем за счет выборки (не производится)
			IF @Type not in ('Вгк', 'Впк')
			SET @Volume = @Volume + @OverVolume * ISNULL( CAST( @Count as NUMERIC( 17, 0 ) ), 0 )

			SET @Part = @PART_CALC

		END

	    -- двоеточие означает, что начинается первая часть описания дефекта, а собранное до этого - ненужное значение номера пленки	
		-- точка с запятой означает, что закончен разбор описания дефекта и ожидается, что дальше будет еще одно
		-- в любом случае, очищаем 
		IF @Symbol in ( ':', ';' )
		BEGIN
            --SET @Trace = @Trace + 'Встречено ":" или ";"' + char(13)

		    SET @Part   = @PART_COUNT                                                        
		    SET @Count  = ''
			SET @Type   = ''
			SET @Length = ''
		END



		-- переходим к следующей позиции
		SET @StrPos = @StrPos + 1                                                 

	END


	-- последнее описание дефекта может не заканчиваться дополнительной информацией или точкой с запятой
	-- для этого случая считаем по данным которые уже собраны, но конец описания дефекта не обнаружен
	IF @Part <> @PART_CALC
	BEGIN

		-- отсутствующее количество дефектов приводим к 1
		IF @Count = '' SET @Count = '1'                                       
		
		IF @Type not in ('Вгк', 'Впк')	
		SET @Volume = @Volume + @OverVolume * ISNULL( CAST( @Count as NUMERIC( 17, 0 ) ), 0 )

		SET @part = @PART_CALC

	END


	RETURN @Volume

END
